{
  "type": "Die Basics",
  "description": "Grundlagen für den OOP-Kurs",
  "author": "Daniela Krapf",
  "number_of_steps": "14",
  "steps": [
    {
      "title": "IntelliJ für OOP",
      "content": "Schön, dass du diesen interaktiven Rundgang mitmachen möchtest. Da du aber vermutlich gerade im Einsteigerkurs für Programmieranfänger (OOP) bist, möchte ich dir gerne einige Grundlagen von IntelliJ zeigen. Sobald du den Rundgang startest, gehen wir die grundlegenden Schritte durch, die dich im OOP-Kurs ganz einfach zu dem Punkt bringen, an dem du die Übungsaufgaben bearbeiten kannst. Im Gegensatz zum klassischen Editor bietet eine integrierte Entwicklungsumgebung (IDE) viele Vorteile. Die IDE IntelliJ ist daher auch ziemlich umfangreich, schließlich soll es vor allem bei der professionellen Entwicklung von Programmen helfen. Es gibt eine Vielzahl an Features, wie du als Entwickler deine Produktivität damit steigern kannst.\n\nStell vor dem Start bitte sicher, dass die Projekt-SDK definiert ist.",
      "pos": 0,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "INTRO_SCREEN"
        }
      ]
    },
    {
      "title": "Das Projekt",
      "content": "Fast alles, was du mit der IDE machst, passiert innerhalb eines Projekts. Alles, was du in IntelliJ machst passiert im Kontext eines Projektes, dieses ist dabei der Container für den gesamten Code.\n\nJedes Projekt braucht eine SDK (für Java JDK genannt), um funktionieren zu können - damit wird definiert, wie das build-Prozess abläuft.\n\nDas Projekt-Werkzeugfenster (project tool window) hier zeigt dir die Struktur des Projekts. Dort kannst du auch neue Dateien erstellen, die meisten Funktionen findest du über das Kontextmenü, das du an der gewünschten Stelle mit der rechten Maustaste öffnen kannst.",
      "pos": 1,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "INTRO_SCREEN"
        },
        {
          "arrow": "LEFT",
          "target-name": "PROJECT_TOOLWINDOW"
        }
      ]
    },
    {
      "title": "Darstellung der Projektstruktur",
      "content": "Falls dir dieses Projekt-Fenster zu unübersichtlich ist, kannst du hier die Ansicht anpassen.\n\nGerade befinden wir uns in der Projekt-Ansicht. Du siehst alles, was zum Projekt gehört, also auch SDKs und Librarys. Der Fokus liegt aber auf der Ordner-Struktur.",
      "pos": 2,
      "targets": [
        {
          "arrow": "UP",
          "target-name": "PROJECT_DROPDOWN"
        }
      ]
    },
    {
      "title": "Verschiedene Darstellungsformen",
      "content": "Um diese Ansicht zu ändern, klicke auf die Schaltfläche „Project“, um das Dropdown aufzuklappen. Wenn du dann zum Beispiel auf „Packages“ klickst, siehst du hier die Package-Struktur, Module, Libraries und SDKs werden nicht mehr angezeigt. Du kannst dich also ganz auf die Klassen und Dateien für deine Übungsaufgabe konzentrieren.\n\nProbiers doch mal aus, für den weiteren Rundgang bleiben wir allerdings in der Project-Ansicht.",
      "pos": 3,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "PROJECT_DROPDOWN_POPUP"
        },
        {
          "arrow": "LEFT",
          "target-name": "PROJECT_DROPDOWN"
        }
      ]
    },
    {
      "title": "Der für den OOP-Kurs relevante Ordner",
      "content": "Da wir hier in einem Einsteigerkurs sind, ist schon eine grobe Projektstruktur vorgegeben und wir müssen uns die Basis nicht selbst aufbauen.\n\nHier im Projekt befinden sich also alle Dateien und Unterordner, mit denen wir arbeiten und die wir ausbauen wollen. Genauer gesagt: im src-Ordner.\n\nDie Klasse mit dem Begriff „Launcher“ im Namen ist hier nur dazu da, um die Anwendung zu starten. Sie enthält die Main-Methode und muss von dir nicht weiter ergänzt werden.\n\nDie zweite Klasse hingegen ist die Wurzel für deinen Code und der Einstieg in das Programm. Öffne sie und schau dir den Code im Editor an.",
      "pos": 4,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "PROJECT_TOOLWINDOW"
        }
      ]
    },
    {
      "title": "Der Code-Editor",
      "content": "Hier im Editor findest du jetzt die geöffnete Klassendatei. Man könnte behaupten, der Editor ist das Herzstück der Entwicklungsumgebung, weil du hier deinen Code schreibst.\n\nIntelliJ bietet dir dabei zahlreiche Hilfestellungen – falls du dich dafür interessierst, schau doch mal in die Doku, da gibt es zahlreiche Tipps ;)\n\nDiese Einstiegsdatei erbt von der GraphicsApp, damit du alle ihre Funktionen verwenden kannst. Hier findest du eine init-Methode, eine draw-Methode und ein paar Konstanten vorgegeben, die du später erweitern sollst.",
      "pos": 5,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "CODE"
        }
      ]
    },
    {
      "title": "Der Run-Prozess",
      "content": "Um zu testen, ob deine Erweiterungen funktionieren und wo es fehler gibt, solltest du dein Programm regelmäßig starten. Hier oben siehst du den Run- und den Debug-Button. Über beide Schaltflächen kannst du dein Programm starten, wobei dir der Debug-Modus später in diesem Kurs noch erklärt wird.\n\nWenn der Run-Button hier noch ausgegraut ist, starte dein Programm erstmalig, indem du die Datei mit der Main-Methode auswählst, also die Launcher-Datei, und klicke auf den kleinen Run-Button in der Editorleiste links neben dem Code.\n\nSobald du auf den Run-Button klickst, starten im Hintergrund der IDE einige Prozesse – sofern du keine Kompilierfehler (ROT) mehr im Code hast: Zunächst wird eine sogenannte „Temporäre Run-Konfiguration“ erstellt. Da Java eine kompilierte Programmiersprache ist, hilft uns die IDE hier und baut den Code automatisch für uns, sobald wir das Programm starten wollen.",
      "pos": 6,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "RUN_BUTTON"
        }
      ]
    },
    {
      "title": "Die Graphics-App",
      "content": "Weil es in der Launch-Datei so definiert ist, öffnet sich bei Start des Programms die Graphics-App. Diese ist eingebunden über die GraphicsApp-Library und ist an sich eine einfache 2D-Grafikumgebung zum Erstellen und Darstellen graphischer Primitive.\n\nIm Hintergrund siehst du, dass beim Starten des Run-Prozesses unten ein neues ToolWindow geöffnet wurde. Hier findest du das Ergebnis des Prozesses oder auch Hinweise zu Fehlern, die auftauchen.\n\nZum Beenden der Anwendung, klicke auf den Stop-Button oder schließe die Instanz der Graphics-App.",
      "pos": 7,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "GRAPHICS_APP"
        }
      ]
    },
    {
      "title": "Der out-Ordner",
      "content": "Außerdem wurde von der IDE das out-Directory erstellt - hier orange hervorgehoben. Dieses enthält alle von IntelliJ kompilierten Klassen.\n\nFun-Fact:\nÖffnet man eine der Klassen im out-Directory, findet man einen Kommentar: Source code recreated from a .class file by IntelliJ IDEA (powered by Fernflower decompiler).\n\nEin Decompiler wandelt Bytecode zurück in lesbaren Code. Man kann ihn also dafür nutzen, sich eine Bibliothek anzusehen, auf deren Quellcode man keinen Zugriff hat. Vor 2014 musste man sich dafür ein Plugin installieren.",
      "pos": 8,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "PROJECT_TOOLWINDOW"
        }
      ]
    },
    {
      "title": "Erstellen einer Klasse",
      "content": "Da es unter anderem aus Gründen der Übersichtlichkeit sehr sinnvoll ist, die Funktionsweise deiner Anwendung auf verschiedene Klassen aufzuteilen, wollen wir als nächstes eine neue Klasse im src-Ordner erstellen.\n\nDurch Rechtsklick auf den src-Ordner öffnest du das Kontextmenü dafür. Wähle hier ganz oben *new >* und klicke dort *Java Class*.\n\nDadurch öffnet sich ein Dialog mit 5 Optionen. Relevant für diesen Kurs werden die ersten drei davon: abgesehen von der Option, eine Klasse zu erstellen, können wir auch Interface oder Enum auswählen. Der Unterschied zwischen Interface und Klasse wird im Kurs behandelt.\n\nEin Enum kannst du beispielsweise dann verwenden, wenn eine Variable nur eine Ausprägung aus einer Liste an Ausprägungen annehmen kann. Das Enum dokumentiert dann, welche Werte überhaupt nutzbar sind.\n\nWir wollen allerdings eine Klasse erstellen. Da diese Option schon vorausgewählt ist, musst du nur noch den Namen der neuen Klasse eingeben, zum Beispiel „Lander“ und das mit Enter bestätigen.",
      "pos": 9,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "PROJECT_TOOLWINDOW"
        }
      ]
    },
    {
      "title": "Die Klassendatei",
      "content": "Die neu erstellte Klassen-Datei öffnet sich automatisch im Editor und erscheint im Projekt-Baum. Sie ist weitestgehend leer und noch keinem Package zugeordnet, erbt nicht und implementiert noch kein Interface. Außerdem hat sie noch keinen Konstruktor.\n\nNachdem du dir Gedanken um den Aufbau deines Codes gemacht hast, kannt du hier anfangen, ihn zu implementieren. Ein Problem, auf das du dabei stoßen könntest, möchte ich noch ansprechen.",
      "pos": 10,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "CODE"
        },
        {
          "arrow": "NONE",
          "target-name": "PROJECT_TOOLWINDOW"
        }
      ]
    },
    {
      "title": "Auswahl des Imports",
      "content": "Wenn du eine Instanz einer Klasse erstellen willst, die du nicht selbst geschrieben hast (hier das Ellipsen-Objekt der GraphicsApp), wirst du zunächst einen Compiler-Error sehen. Warum? Ganz einfach: um eine externe Klasse verwenden zu können, musst du sie oder ihr zugehöriges Package zuerst importieren.\n\nBewege deine Maus dazu auf das rot hinterlegte wort *Ellipse*. Jetzt hast du zwei Optionen: wenn du mit der Maus über das Wort hoverst, kommt ein Dialog, in dem du *import class* wählst - oder du gehst über die Tastatur. Klicke dafür auf das Wort und dann Alt+Enter. Unter *import class* bekommst du dann eine Auswahl aller möglichen Importe: Wähle in diesem Fall den aus dem de.ur.mi.oop-Package (grau in Klammern).",
      "pos": 11,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "CODE"
        }
      ]
    },
    {
      "title": "Das Import-Statement",
      "content": "Sobald du die Klasse importiert hast, erscheint das Statement am Anfang der Datei. Hier oben siehst du, welche Klassen aus welchen Packages du importiert hast – in diesem Fall nur diese eine. Sobald du mehr als 5 Klassen aus dem selben Package importieren willst, versucht IntelliJ die Import-Ansicht übersichtlicher zu machen, indem nicht mehr die einzelnen Klassen des Packages importiert werden, sondern das gesamte Package, was dann so aussieht: de.ur.mi.oop.graphics.*\n\nAber was bedeutet Import? Ein IntelliJ-Projekt besteht aus Modulen. Ein Modul kann unabhängig von anderen Modulen laufen und verschiedene Dateien enthalten: Quellcode, Skripte, Dokumentation, Ressourcen, etc. Die Dateien dieser Module, die in Packages gruppiert sind, kannst du dann in deinem Projekt importieren.",
      "pos": 12,
      "targets": [
        {
          "arrow": "UP",
          "target-name": "IMPORT_STATEMENT"
        }
      ]
    },
    {
      "title": "Rundgang beendet",
      "content": "Damit sind wir auch schon wieder durch mit diesem ersten Überblick.\n\nSchön, dass du dabei warst, gib gerne Feedback dazu, wie hilfreich die Informationen für dich waren und für welche Bereiche du dir noch mehr Erklärungen wünschst.\n\nJetzt kannst du den Rundgang beenden und mit deinem eigenen Übungsprojekt anfangen. Falls du dir den Rundgang nochmal genauer ansehen willst, kannst du ihn auch neu starten.",
      "pos": 13,
      "targets": [
        {
          "arrow": "NONE",
          "target-name": "OUTRO_SCREEN"
        }
      ]
    }
  ]
}